---
title: 数据结构（一） #标题
categories: 数据结构 #分类，可多个；若单个去掉括号
tags: [数据结构, 堆, 栈, 图, 树] #标签，可多个；若单个去掉括号
mathjax: true #是否引用公式
kewords: #本文关键词
description: #本文描述，若为空就自动全文前150字)
copyright: true #是否需要版权申明，默认有
reward: true #是否需要打赏，默认有
toc: true #是否需要目录，默认有
password: #是否加密，为空不加密
date: 2018-1-28 20:02 #日期
---


# 字符串
设字符串S='ABCDEFG',T='PQRST',则运算CONCAT(SUBSTR(S,2，LENGTH(T),SUBSTR(S,LENGTH(T),2) ))后的结果为（）
A.'BCQR'
B.'BCDEF'
C.'BCDEFG'
D.'BCDEFEF'

1. oracle中取得字符串中指定起始位置和长度的字符串substr( string, start_position, [ length ] )，计数从1开始，字符串长度不带“\0”

2. concat() 方法用于连接两个或多个数组。 

3. substr是C++语言函数，主要功能是复制子字符串，要求从指定位置开始，并具有指定的长度。

4. SUBSTR(S,2，LENGTH(T) )
5. 如果没有指定长度_Count或_Count+_Off超出了源字符串的长度，则子字符串将延续到源字符串的结尾。
oracle中字符下标从1开始，此处为从字符串S的第2个开始，截取长度为LENGTH(T)即5的字符串
结果为：BCDEF
SUBSTR(S,LENGTH(T),2)，从字符串S的第LENGTH(T)即第5个开始，截取长度为2的字符串
结果为：EF
CONCAT结果为：BCDEFEF

下面关于字符串的描述正确的是：【多选】（ ）
A.通过String s1=new String("abc")和String s2="abc"，则s1==s2为true。
B."abc"+"def"则会创建三个字符串对象，第三个是"abcdef"。也就是说，在Java中对字符串的一切操作，都会产生一个新的字符串对象。
C.StringBuffer是线程安全的，它比String快。
D.StringBuilder是线程安全的，它比String快

1. 三者执行速度：StringBuilder > StringBuffer > String ；
2. StringBuilder：线程非安全的；
3. StringBuffer：线程安全的；
4. 用String操作字符串时，实际上是在不断地创建新对象，而原来的对象会作为垃圾被回收；

对于A： s1利用new 操作后，为该对象在堆（Heap）区分配了一块内存； s2是字符串常量，存放在内存的”文字常量区“ ；虽然两个对象的值相同，但由于两者位于不同的地址，不是相同的对象，因此 s1==s2 为false。 A错

# 多型数据类型
1. 多型数据类型是指包含的数据元素的类型并不确定。
2. 比如栈可以是整数栈、字符栈、对象栈等等。
3. 但是字符串，它的元素必然是字符。

4. 设模式串的长度为m,目标串的长度为n,当n≈m且处理只匹配一次的模式时,朴素的匹配(即子串定位函数)算法所花的时间代价可能会更为节省()
A.对
B.错

朴素的匹配只匹配一次，不用计算next数组，所以速度更快

字符串的朴素算法(就是暴力搜索）

---
# 子串
1. n 个字符构成的字符串，假设每个字符都不一样，问有多少个子串？
A. n+1
B.n(n+1)/2 + 1
C.2^n-1
D.n!

这么想就很简单：
长度为 1 的字符串 n 个
长度为 2 的 n-1 个
长度为 3 的 n-2 个
...
长度为 n 的 1 个
然后 n+(n-1)+(n-2)+...+1 =n(n+1)/2

2. 下面程序段的输出结果是D

```c
char *p1 = ”123”, *p2 = ”ABC”, str[50] = “xyz”;
strcpy(str + 2, strcat(p1, p2));
printf(“%s\n”, str);
```

A.xyz123ABC
B.z123ABC
C.xy123ABC
D.出错

原代码有错：
1. p1和p2都指向常量字符串，在常量区，所以不能对其进行操作；
2. 改为数组即可，但是用字符串初始化数组时要记得将数组长度加1，因为字符串默认的末尾有一个‘\0’；
3. 第二点要注意的是，strcat函数的p1要有足够的空间来容纳p1和p2连接后的串长。

修改为以下代码将可以：
```c
char p1[7] = "123";
char p2[] = "ABC";
char str[50] = "xyz";
strcpy(str + 2, strcat(p1, p2));
printf("%s\n", str);
```

char *p1="123" 声明了个字符串指针p1，指向字符串“ 123 ”，此时的“ 123 ”存放在常量区，并没有在拷贝到栈中，所以不能修改，如修改p1[0] = '2'就是错误的。
建议改为char p1[10] = "123"，就可以修改p1的值。

# 空串和由空格组成的串
1. 空串：a=“没有东西”；
2. 空格串：b=“空格空格”
3. 所以空串和空格串是不一样的
4. 想像使用split()方法时，这两个参数得到的结果肯定不一样

#有关赋值
不能所字符串“Good!”存放到数组 s 中的代码是（D）
A.char s[8] = {'G','o','o','d','!', '\0'};
B.char s[8];
strcpy(s, "Good!");
C.char s[8];
s = "Good!";
D.char s[8] = "Good!";

1. char数组只有在初始化的时候才能整体赋值
2. char s[8],表示s是一个不可修改的左值，s实际上是char *const s 类型的值

# KMP
1. KMP算法的特点是在模式匹配时指示主串的指针不会变小
2. KMP算法最大的特点就是指示主串的指针不需要回溯，因此指针不可能变小

# NEXT数组
串′ababaaababaa′的next数组为(011234223456)

第一种方法：
1. next数组的求解方法是：第一位的next值为0，第二位的next值为1，后面求解每一位的next值时，根据前一位进行比较。
2. 首先将前一位与其next值对应的内容进行比较，如果相等，则该位的next值就是前一位的next值加上1；
3. 如果不等，向前继续寻找next值对应的内容来与前一位进行比较，直到找到某个位上内容的next值对应的内容与前一位相等为止，则这个位对应的值加上1即为需求的next值；
4. 如果找到第一位都没有找到与前一位相等的内容，那么需求的位上的next值即为1。

第二种解释：
next数组下标从1开始计算
next[1] 肯定是 0 
next[2] 肯定是 1
next[n] 的情况，将前面n-1个字符，计算从首尾开始组成最大的相同子串的长度，如果找到，那么next值是该长度加1，否则next值是1。

举例
next[6]的计算，字符串第六位是 a ，( ababa a ababaa)
将前面的5个字符，从头尾开始取4个组成子串比较，如果不相等，则从首尾取3个字符组成子串继续比较，并以此类推， 如果一直比较到最后一个字符都不相等，那么该next值为1。
4个字符的情况：abab : baba
3个字符的情况：aba   :  aba  此时相等，那么next[6] = 3+1 = 4

第三种（在看不懂我就没办法了）

```
     i     0    1    2    3    4    5   6   7    8   9   10   11
     s     a    b    a    b    a    a   a   b    a    b   a    a  
next[i]   -1    0    0   1     2    3   1   1    2    3   4    5
```

1. 先计算前缀next[i]的值： （字符串匹配是 从头开始的 和 从尾开始的字符串进行匹配是否重复 ）
2. next[i]的值主要是看s[i]之前的字符串中重复的子串长度。next[0] = -1，定值。  
3. next[1]是看s[1]之前的字符串“a”中重复的子串长度为0，故next[1] = 0。
4. next[2]是看s[2]之前的字符串“ab”中重复的子串长度为0，故next[2] = 0。
5. next[3]是看s[3]之前的字符串"aba"中重复的子串长度，s[0]与s[2]重复，长度为1，故next[3] = 1。
6. next[4]是看s[4]之前的字符串"abab"中重复的子串长度，s[01]与s[23]重复，长度为2，故next[4] = 2。
7. next[5]是看s[5]之前的字符串"ababa"中重复的子串长度，s[012]与s[234]重复，长度为3，故next[5] = 3。
8. next[6]是看s[6]之前的字符串"ababaa"中重复的子串长度，s[0]与s[5]重复(因为多了一个a，无法找到长度为3的重复字符串，这只能是s[0]和s[5]重复)，长度为1，故next[6] = 1。
9. 同样的，求next[7]和next[8]、next[9]、 next[10]、 next[11] 分别为1和2、3、4、5。

# 指针和数组
```
#include<stdio.h>
char *myString()
{
    char buffer[6] = {0};
    char *s = "Hello World!";
    for (int i = 0; i < sizeof(buffer) - 1; i++)
    {
        buffer[i] = *(s + i);
    }
    return buffer;
}
int main(int argc, char **argv)
{
    printf("%s\n", myString());
    return 0;
}
```
输出结果？

1. 函数char *myString()中没有使用new或者malloc分配内存，所有buffer数组的内存区域在栈区
2. 随着char *myString()的结束，栈区内存释放，字符数组也就不存在了，所以会产生野指针，输出结果未知 
