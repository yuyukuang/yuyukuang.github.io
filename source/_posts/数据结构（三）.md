---
title: 数据结构（三） #标题
categories: 数据结构 #分类，可多个；若单个去掉括号
tags: [数据结构, 堆, 栈, 图, 树] #标签，可多个；若单个去掉括号
mathjax: true #是否引用公式
kewords: #本文关键词
description: #本文描述，若为空就自动全文前150字)
copyright: true #是否需要版权申明，默认有
reward: true #是否需要打赏，默认有
toc: true #是否需要目录，默认有
password: #是否加密，为空不加密
date: 2018-1-31 22:50:02 #日期
---


# 折半查找与顺序查找
两者查找速度比较：
例如在一个数组中有10个元素.

1. 第一个是要找的元素.
   折半查找：先找第六（下标为5）个,再找第三个（下标为2）,然后是第二个（下标为1）,最后是第一个（下标为0）...
   顺序查找：只要找一次就ok了.

2. 第10个是要找的元素.
   折半查找：先找第六（下标为5）个,再找第八个（下标为7）,然后是第九个（下标为8）,最后是第十个（下标为9）...
   顺序查找：需要10次.

3. 第三个是要找的元素.
   折半查找：先找第六（下标为5）个,再找第三个（下标为2）
   顺序查找：需要三次（效率一样）.

# 折半查找
用向量和单链表示的有序表均可使用折半查找方法来提高查找速度(错)

1. 折半查找属于随机访问特性 链表不行
2. 堆排序也不能用链表 因为调整堆时没法随机访问底层孩子节点
3. 快速排序可以链表
4. 归并排序可用链表
5. 基数排序可用链表
6. 插入排序链表比数组要快一些 减少移动次数


具有12个关键字的有序表,折半查找的平均查找长度()

将12个数画成完全二叉树，第一层有1个、第二次2个、第三层4个，第四层只有5个。
二分查找时：
第一层需要比较1次
第二两个数，每个比较2次
第三层四个数，每个比较3次
第四层五个数，每个比较4次
则平均查找长度即为：（1+2*2+3*4+4*5）/12 = 37/12 = 3.0833 即为 A、3.1

# 动态查找与静态查找
适于对动态查找表进行高效率查找的组织结构是分块有序表(错)

1. 分块查找是静态查找
2. 动态查找有二叉排序树查找，最优二叉树查找，键树查找，哈希表查找

静态查找表只进行以下2个操作：
    1.查找某个“特定”数据元素是否在查找表中
    2.查找某个“特定”数据元素的各种属性
    有序表、分块有序表、线性链表都是静态查找表
性能分析：平均查找长度：（当查找关键字等概率时）ASL = 1/(n+1)

动态查找表:表结构是在查找过程中动态生成的，通俗解释，对于给定key,若表中存在某关键字与key相等则查找成功返回，若未找到则插入关键字等于key的记录。
        二叉排序树、平衡二叉树、B树、B+树都是动态查找。（对查找表进行插入和删除操作---即为动态的）


# 平均查找长度
就平均查找长度而言,分块查找最小,折半查找次之,顺序查找最大(错)

 分快查找，是将顺序表分为若干块，块内元素顺序任意，块间有序，即前一块中的最大值小于后一块中的最小值。并且有一张索引表，每一项存放每一块的最大值和指向该块第一个元素的指针。索引表有序，块内无序。所以，块间查找用二分查找，块内用顺序查找，效率介于顺序和二分之间。

分块查找：
1.将顺序表分为若干块，除最后一块，前面每块元素相等，块间有序，块内无序
2.索引表内元素有序，用二分折半查找，每块内元素无序，用顺序查找
3.所以分块查找介于折半查找和顺序查找之间

# 判断是否有环
判断是否有环方法：
1.拓扑排序
2.深度优先遍历
3.广度优先遍历
